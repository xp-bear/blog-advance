---
title: Django 框架教程
categories:
  - Django
tags:
  - Django
---

# Django 框架教程

## 1. Django 框架介绍与安装

### 1.1 Web 开发介绍：

- 目前 Web 开发属于 Browser/Server 模式，简称 B/S 架构，开发语言有（Python、PHP、Java 、node.js ...）。
- 基于 Python 的 Web 工作原理如下：
  ![img](http://mk.xxoutman.cn/django/webjg.png)

### 1.2 框架介绍：

**①. 什么是框架?**

- 软件框架就是为实现或完成某种软件开发时,提供了一些基础的软件产品,
- 框架的功能类似于`基础设施`,提供并实现最为`基础的软件架构和体系`
- 通常情况下我们依据框架来实现更为复杂的业务程序开发
- 二个字,框架就是程序的`骨架`

**②. 框架的优缺点**

- 可重用
- 成熟,稳健
- 易扩展、易维护

**③. Python 中常见的框架**

- 大包大揽 Django 被官方称之为完美主义者的 Web 框架。
- 力求精简 web.py 和 Tornado
- 新生代微框架 Flask 和 Bottle

**④. Web 框架中的一些概念**

- MVC
  - 大部分开发语言中都有 MVC 框架
  - MVC 框架的核心思想是：解耦
  - 降低各功能模块之间的耦合性，方便变更，更容易重构代码，最大程度上实现代码的重用
  - m 表示 model，主要用于对数据库层的封装
  - v 表示 view，用于向用户展示结果
  - c 表示 controller，是核心，用于处理请求、获取数据、返回结果
- MVT
  - Django 是一款 python 的 web 开发框架
  - 与 MVC 有所不同，属于 MVT 框架
  - m 表示 model，负责与数据库交互
  - v 表示 view，是核心，负责接收请求、获取数据、返回结果
  - t 表示 template，负责呈现内容到浏览器

### 1.3 Django 框架介绍

- Django 是一个高级的 Python Web 框架，它鼓励快速开发和清洁，务实的设计。

- 由经验丰富的开发人员构建，它负责 Web 开发的许多麻烦，因此您可以专注于编写应用程序，而无需重新创建轮子。

- 它是免费的和开源的。

- 被官方称之为完美主义者的 Web 框架。

- Django 可以更快地构建更好的 Web 应用程序并减少代码。

  官方网址：https://www.djangoproject.com/

**① Django 框架的特点：**

- 快速开发：Django 的宗旨在于帮助开发人员快速从概念到完成应用程序。
- 安全可靠：Django 认真对待安全性，帮助开发人员避免许多常见的安全错误。
- 超可伸缩性：Web 上的一些最繁忙的网站利用了 Django 快速灵活扩展的能力。

**② Django 可以使用什么 Python 版本？**

| Django 版本   | Python 版本                           |
| :------------ | :------------------------------------ |
| 2.2           | 3.5、3.6、3.7、3.8（在 2.2.8 中添加） |
| 3.0、3.1、3.2 | 3.6、3.7、3.8                         |

- Django 的开发版本

![img](http://mk.xxoutman.cn/django/release-roadmap.e844db08610e.png)

![img](http://mk.xxoutman.cn/django/22.png)

### 1.4 Django 的安装

- 作为 Python Web 框架，Django 需要 Python，在安装 Python 同时需要安装 pip。

```python
在线安装Django,指定版本安装，目前2.2的最新版为2.2.24
pip install django==2.2.*

# 默认会安装：Django==2.2.24、sqlparse==0.3.1 和 pytz==2020.1

检测当前是否安装Django及版本
python -m django --version

# 输出结果 2.2.24
# 我们也可以先下载安装包：pip download django=2.2.13 -d ./
# 指定安装包安装：pip install Django-2.2.13-py2.py3-none-any.whl
```

## 2. Django 的快速入门

### 2.1 项目的创建与运行

如果这是你第一次使用 Django，那么你必须要照顾一些初始设置。也就是说，您需要自动生成一些建立 Django 项目的代码

从命令行 cd 到您要存储代码的目录，然后运行以下命令：

```python
#创建一个django项目
django-admin startproject mysite
```

我们来看看 startproject 创建的内容：

```python
# 文件视图
├── manage.py # 一个命令行实用程序，可以让您以各种方式与此Django项目进行交互。
└── mysite  # 您的项目的实际Python包
    ├── __init__.py # 被认为是一个Python包。
    ├── settings.py # Django项目的设置/配置
    ├── urls.py # 您的Django网站的“目录” (根路由)
    └── wsgi.py # Web服务器为您的项目提供服务的入口点(部署项目的文件)
```

关于上面自动生成的目录与文件解释如下：

- 外部 mysite/根目录只是一个项目的容器。它的名字与 Django 无关; 您可以将其重命名为您喜欢的任何内容。
- manage.py：一个命令行实用程序，可以让您以各种方式与此 Django 项目进行交互。你可以阅读所有的细节 manage.py 在 Django 的管理和 manage.py。
- 内部 mysite/目录是您的项目的实际 Python 包。它的名字是您需要用来导入其中的任何内容的 Python 包名称（例如`mysite.urls`）。
- 内部 mysite/\_\_init\_\_.py：一个空的文件，告诉 Python 这个目录应该被认为是一个 Python 包。
- 内部 mysite/settings.py：此 Django 项目的设置/配置。 Django 设置会告诉你所有关于设置的工作原理。
- 内部 mysite/urls.py：该 Django 项目的 URL 声明; 您的 Django 网站的“目录” (根路由)。
- 内部 mysite/wsgi.py：WSGI 兼容的 Web 服务器为您的项目提供服务的入口点(部署项目的文件)。

#### 1.启动 django 项目

我们来验证您的 Django 项目的作品。启动我们自己的 django 项目

```python
python manage.py runserver
```

这是一个纯粹以 Python 编写的轻量级 Web 服务器。 我们将其与 Django 结合在一起，因此您可以快速开发，而无需处理配置生产服务器（如 Apache），直到您准备好生产。

默认情况下，该 runserver 命令在端口 8000 的内部 IP 上启动开发服务器。当然也可以指定端口开启服务,如 8080 端口：

```python
python manage.py runserver 8080
```

如果要更改服务器的 IP，请将其与端口一起传递。例如：

```python
python manage.py runserver 0.0.0.0:8000
```

注意：通过 IP 访问后报如下错误：

```python
DisallowedHost at /polls
Invalid HTTP_HOST header: '192.168.*.*:8000'. You may need to add '192.168.*.*' to ALLOWED_HOSTS.

HTTP_HOST标头无效：'192.168.*.*:8000'。您可能需要将“192.168.*.*”添加到ALLOWED_HOSTS
如：ALLOWED_HOSTS = ['192.168.104.240'] 或：ALLOWED_HOSTS = ['*']
```

#### 2.创建一个应用程序

Django 自带一个实用程序，可以自动生成应用程序的基本目录结构，因此您可以专注于编写代码而不是创建目录。

要创建您的应用程序，请确保您与目录位于同一目录，`manage.py` 并键入以下命令：

```python
python manage.py startapp polls
```

这将创建一个目录 polls，其目录如下：

```python
# 文件目录
mysite/
├── manage.py
├── mysite
│   ├── __init__.py
│   ├── settings.py
│   ├── urls.py
│   └── wsgi.py
└── polls
    ├── admin.py	//该应用后台管理系统配置
    ├── apps.py		//该应用的一些配置 1.9以后自动生成
    ├── __init__.py
    ├── migrations  //数据移植（迁移）模块
    │   └── __init__.py
    ├── models.py	//数据模块
    ├── tests.py	//自动化测试模块  在这里编写测试脚本
    └── views.py	//执行响应的代码所在模块  代码逻辑处理主要地点  项目大部分代码在此编写
```

#### 3.定义我们的第一个视图

我们来写第一个视图。打开文件`polls/views.py` 并放入以下 Python 代码：

```python
from django.http import HttpResponse

def index(request):
    return HttpResponse("Hello, world.")
```

这是 Django 中最简单的视图。要调用视图，我们需要将其映射到一个 URL,因此我们需要创建一个路由文件。

要在 polls 目录中创建一个路由文件，创建一个名为`polls/urls.py`。您的应用目录应该如下所示：

```python
└── polls
    ├── admin.py
    ├── apps.py
    ├── __init__.py
    ├── migrations
    │   └── __init__.py
    ├── models.py
    ├── tests.py
    ├── urls.py  #创建一个路由文件
    └── views.py
```

在`polls/urls.py`文件中包含以下代码：

```python
from django.urls import path

from . import views

urlpatterns = [
    path('', views.index, name='index'),
]
```

下一步是将根路由 urls 指向 polls.urls 模块。 在 `mysite/urls.py`根路由文件导入子路由文件,添加一条 import 用于 django.urls.include 和插入 include()的 urlpatterns 列表，所以你必须在`mysite/urls.py`写：

```python
from django.contrib import admin
from django.urls import include,path

urlpatterns = [
    path('admin/', admin.site.urls),
    path('polls/', include('polls.urls')),
]
```

其中 include()函数允许引用其他路由文件。请注意，该 include()函数的正则表达式 没有$（字符串匹配字符），而是尾部的斜杠/。 每当 Django 遇到时 include()，它会排除与该点匹配的任何部分，并将剩余的字符串发送到随附的路由文件中进行进一步处理。

#### 4.path() 函数介绍

Django path() 可以接收四个参数，分别是两个必选参数：`route`、`view` 和两个可选参数：`kwargs`、`name`，接下来详细介绍这四个参数。

- `route` : 是包含 URL 模式的字符串。在处理请求时，会在 urlpatterns 这个列表中依次向下寻找， 沿列表向下移动，将请求的 URL 与每个模式进行比较，直到找到匹配的 URL。
- `view`: 用于执行与正则表达式匹配的 URL 请求。
- `kwargs`: 视图使用的字典类型的参数。
- `name`: 用来反向获取 URL。

### 2.2 体验创建 django 后台

#### 1.创建项目

如果这是你第一次使用 Django，那么你必须要照顾一些初始设置。也就是说，您需要自动生成一些建立 Django 项目的代码

从命令行 cd 到您要存储代码的目录，然后运行以下命令：

```python
django-admin startproject myweb
```

我们来看看 startproject 创建的内容：

```python
# 文件视图
├── manage.py
└── myweb
    ├── __init__.py
    ├── settings.py
    ├── urls.py
    └── wsgi.py
```

**启动项目**

我们来验证您的 Django 项目的作品。更改为外部 myweb 目录，如果您还没有，并运行以下命令：

```python
python manage.py runserver
```

#### 2.创建一个应用程序

Django 自带一个实用程序，可以自动生成应用程序的基本目录结构，因此您可以专注于编写代码而不是创建目录。

要创建您的应用程序，请确保您与目录位于同一目录，manage.py 并键入以下命令：

```python
python manage.py startapp myapp
```

这将创建一个目录 myapp，其目录如下：此目录结构将容纳轮询应用程序。

```python
# 文件视图
myweb/
├── manage.py
├── myweb
│   ├── __init__.py
│   ├── settings.py
│   ├── urls.py
│   └── wsgi.py
└── myapp
    ├── admin.py
    ├── apps.py
    ├── __init__.py
    ├── migrations
    │   └── __init__.py
    ├── models.py
    ├── tests.py
    └── views.py
```

#### 3.编写我们的第一个视图

我们来写第一个视图。打开文件`myapp/views.py` 并放入以下 Python 代码：

```python
from django.http import HttpResponse

def index(request):
    return HttpResponse("Hello, world.")
```

在`myapp/urls.py`文件中包含以下代码：

```python
#创建子路由文件
from django.urls import path
from . import views

urlpatterns = [
    path('', views.index, name='index'),
]
```

下一步是在**根路由**`myweb/urls.py`里面加载我们**应用程序的子路由**`myapp/urls.py`文件

```python
from django.contrib import admin
from django.urls import include,path

urlpatterns = [
    #path('admin/', admin.site.urls),
    path('myapp/', include('myapp.urls')),
]
```

#### 4.创建项目的模型

**(1). 连接 MySQL 数据库设置**

默认情况下，配置使用 SQLite。若不使用 SQLite 作为数据库，则需要额外的设置。例如 USER，PASSWORD 和 HOST 必须加入。

其中 ENGINE 设置为数据库后端使用。内置数据库后端有：

> - 'django.db.backends.postgresql'
> - 'django.db.backends.mysql'
> - 'django.db.backends.sqlite3'
> - 'django.db.backends.oracle'

在`myweb/settings.py`文件中，通过 DATABASES 项进行数据库设置

```python
DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.mysql',
        'NAME': 'mydemo', #数据库名称
        'USER': 'root',	#用户名
        'PASSWORD': 'root',	#密码
        'HOST': 'localhost',
        'PORT': '3306',
    }
}
```

注意：Django 使用 MySQL 数据库需要加载 MySQLdb 模块，需要安装 mysqlclient

```python
pip install  mysqlclient
```

**(2). 创建模型**

我们先在数据库 mydemo 里面创建 stu 这一个表

```mysql
CREATE TABLE `stu` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `name` varchar(16) COLLATE utf8_unicode_ci DEFAULT NULL,
  `age` int(11) DEFAULT NULL,
  `sex` enum('男','女') COLLATE utf8_unicode_ci DEFAULT NULL,
  `classid` int(8) DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=4 DEFAULT CHARSET=utf8 COLLATE=utf8_unicode_ci;
```

然后在我们的简单的应用程序中，去创建一个 stu 表信息操作的 Model 类。编辑 `myapp/models.py`文件

```python
from django.db import models

class Stu(models.Model):
    '''自定义Stu表对应的Model类'''
    id = models.AutoField(primary_key=True)   #定义属性: 默认主键自增id字段可不写
    name = models.CharField(max_length=16)
    age = models.SmallIntegerField()
    sex = models.CharField(max_length=1)
    classid=models.CharField(max_length=8)

    # 定义默认输出格式
    def __str__(self):
        return "%d:%s:%d:%s:%s"%(self.id,self.name,self.age,self.sex,self.classid)

    # 自定义对应的表名，默认表名: myapp_stu
    class Meta:
        db_table="stu"
```

**(3). 激活模型**

要将该应用程序包括在我们的项目中，我们需要在设置中添加对其配置类的引用 INSTALLED_APPS。

编辑`myweb/settings.py`文件

```python
INSTALLED_APPS  =  [
    'django.contrib.admin' ，
    'django.contrib.auth' ，
    'django.contrib.contenttypes' ，
    'django.contrib.sessions' ，
    'django.contrib.messages' ，
    'django.contrib.staticfiles' ，
    'myapp.apps.MyappConfig',  #或者直接写 myapp
]
```

**(4). 使用（两种）**

① 进入交互式的 Python shell

```python
$ python manage.py shell

>>> from myapp.models import Stu  #导入这一个Stu继承的Model类

>>> mod = Stu.objects	# 获取所有信息

>>> lists = mod.all()
>>> for v in lists:
...     print(v)
...
1:zhangsan:22:m:python03  #下面这些是输出的结果
2:lisi:25:w:python04
3:wangwu:20:m:python03
```

② 在 myapp 应用的视图中使用

在`myapp/views.py` 文件中

```python
from django.shortcuts import render
from django.http  import HttpResponse
#from myapp.models import Stu
from .models import Stu

def index(request):
    return HttpResponse("Hello Django!")

def stu(request):
    #获取所有stu表信息
    lists = Stu.objects.all()
    print(lists)
    #获取单条学生信息
    print(Stu.objects.get(id=1))

    return HttpResponse("ok")
```

配置 stu 函数的访问路由，在`myapp/urls.py`文件中配置。

```python
path('stu/', views.stu),
```

启动服务后，在浏览器中访问,在命令行终端中查看输出效果: http://localhost:8000/myapp/stu

#### 5.启用网站 Admin 管理

**(1). 数据迁移**

Django 框架中有一个非常强大的应用功能，自动管理界面，常被 Web 平台管理者使用，去管理整个 Web 平台。

默认情况下，在 settings.py 配置文件中 INSTALLED_APPS 包含以下应用程序，这些应用程序都是由 Django 提供：

```python
django.contrib.admin - 管理网站。你会很快使用它。
django.contrib.auth - 认证系统。
django.contrib.contenttypes - 内容类型的框架。
django.contrib.sessions - 会话框架
django.contrib.messages - 消息框架。
django.contrib.staticfiles - 管理静态文件的框架。
```

为了后续的开发，默认这些应用程序都是包含在里面的。

把迁移文件添加到模型中。在这个地方不需要执行这一个语句,执行下一个语句,增量映射表的数据,在执行这一句代码

```py
python manage.py makemigrations
```

使用这些 Django 自带的应用程序，需要我们在数据库中创建一些数据表对应，然后才能使用它们。为此，请运行以下命令（数据结构迁移）：

```python
python manage.py migrate
```

其中该`migrate`命令查看该`INSTALLED_APPS`设置，并根据`myweb/settings.py`文件中的数据库设置和应用程序随附的数据库迁移创建任何必需的数据库表您会看到适用于每个迁移的消息。

```python
执行上面命令后的输出结果
Operations to perform:
  Apply all migrations: admin, auth, contenttypes, sessions
Running migrations:
  Applying contenttypes.0001_initial... OK
  Applying auth.0001_initial... OK
  Applying admin.0001_initial... OK
  Applying admin.0002_logentry_remove_auto_add... OK
  Applying contenttypes.0002_remove_content_type_name... OK
  Applying auth.0002_alter_permission_name_max_length... OK
  Applying auth.0003_alter_user_email_max_length... OK
  Applying auth.0004_alter_user_username_opts... OK
  Applying auth.0005_alter_user_last_login_null... OK
  Applying auth.0006_require_contenttypes_0002... OK
  Applying auth.0007_alter_validators_add_error_messages... OK
  Applying auth.0008_alter_user_username_max_length... OK
  Applying sessions.0001_initial... OK
  # 默认情况下自动在我们的数据库中创建了10张表
| auth_group                 |
| auth_group_permissions     |
| auth_permission            |
| auth_user                  |
| auth_user_groups           |
| auth_user_user_permissions |
| django_admin_log           |
| django_content_type        |
| django_migrations          |
| django_session             |
| stu
```

**(2). 创建管理员用户**

首先，我们需要创建一个可以登录管理站点的用户。运行以下命令：

```python
python manage.py createsuperuser

# 输入您所需的用户名，然后按Enter键。
Username: admin

# 然后将提示您输入所需的电子邮件地址：
Email address: admin@qq.com

# 最后一步是输入你的密码12345678（>=8位）。您将被要求输入密码两次，第二次作为第一次的确认
Password: **********
Password (again): *********
Superuser created successfully.
```

**(3). 启动项目服务**

默认情况下，Django 管理员站点被激活。让我们开始开发服务器并探索它。启动开发服务器命令如下：

```python
python manage.py runserver
```

现在，打开一个 Web 浏览器，访问地址： http://127.0.0.1:8000/admin/

**(4). 设置时区和语言**

编辑`myweb/settings.py`配置文件：

```python
...
LANGUAGE_CODE = 'zh-hans'
TIME_ZONE = 'Asia/Shanghai'
...
```

**(5). 将我们自定义的应用程序的加入到后台管理**

但我们的自定义应用程序在哪里？并没有显示在后台管理索引页面上。

要做到这一点，打开`myapp/admin.py `文件，并编辑代码如下：

```python
#添加应用程序到后台索引

from django.contrib import admin
from myapp.models import Stu

admin.site.register(Stu)
```

**(6). 更深入设计后台管理**

编辑`myapp/models.py`文件，在 Stu 类中添加如下信息，让后台管理显示中文字段。

```python
class Stu(models.Model):
    '''自定义Stu表对应的Model类'''
    #定义属性：默认主键自增id字段可不写
    id = models.AutoField("学号",primary_key=True)
    name = models.CharField("姓名",max_length=16)
    age = models.SmallIntegerField("年龄")
    sex = models.CharField("性别",max_length=1)
    classid=models.CharField("班级",max_length=8)

    # 定义默认输出格式
    def __str__(self):
        return "%d:%s:%d:%s:%s"%(self.id,self.name,self.age,self.sex,self.classid)

    # 自定义对应的表名，默认表名：myapp_stu
    class Meta:
        db_table="stu"
        verbose_name = '浏览学生信息'  #表里面的显示,(选择浏览学生信息来修改)
        verbose_name_plural = '学生信息管理' #后台显示的表名称
```

编辑`myapp/admin.py `文件，实现信息管理的个性化定制

```python
from django.contrib import admin

# Register your models here.
from myapp.models import Stu

#Stu模型的管理器(装饰器写法)
@admin.register(Stu)
class StuAdmin(admin.ModelAdmin):
    #listdisplay设置要显示在列表中的字段（id字段是Django模型的默认主键）
    list_display = ('id','name','age','sex','classid')

    #设置哪些字段可以点击进入编辑界面
    list_display_links = ('id','name')

    #list_per_page设置每页显示多少条记录，默认是100条
    list_per_page = 10

    #ordering设置默认排序字段，负号表示降序排序
    ordering = ('id',)  #id降序

    #list_editable 设置默认可编辑字段
    #list_editable = ['age','sex','classid']
```

### 2.3 URL 路由(URL 配置)

Django 可以让你 自己设计 URL ，无论你想要什么，没有框架限制。

为了给一个应用设计 URL，你需要创建一个 Python 模块，通常被称为路由文件`urls.py`。

首先先创建一个 django 项目:

```py
# 创建一个mydemo项目
django-admin startproject mydemo
```

```py
# 创建一个myapp应用程序
python manage.py startapp myapp
```

在`mydemo/urls.py`中配置路由

```py
from django.contrib import admin
from django.urls import path, include
from myapp import views

urlpatterns = [
    path('admin/', admin.site.urls),
    path('aa/', views.index)
]
```

在`myapp/views.py`中配置视图

```py
from django.shortcuts import render
from django.http import HttpResponse


# Create your views here.
def index(request):
    return HttpResponse('index首页')
```

![image-20220905213153016](http://mk.xxoutman.cn/django/image-20220905213153016.png)

**1.路由加载规则**

当用户从 Django 的站点请求页面时，Django 系统遵循以下步骤来执行的 Python 代码：

1. 首先 Django 确定要使用的 根路由 模块，通过`ROOT_URLCONF`来设置，具体在`settings.py`配置文件中。但是如果传入 `HttpRequest`对象具有`urlconf` 属性（由中间件设置），则其值将用于替换`ROOT_URLCONF`设置。
2. Django 加载该 Python 模块并查找该变量 `urlpatterns`。它是`django.urls.path()` 或 `django.urls.re_path()`实例的序列(sequence)。
3. Django 按顺序运行每个 URL 模式，并在匹配所请求的 URL 的**第一个**URL 中停止。
4. 一旦正则表达式匹配，Django 将导入并调用给定的视图。该视图会获得如下参数：
   - 一个`HttpRequest`实例。
   - 如果匹配的正则表达式没有返回任何命名组，那么来自正则表达式的匹配将作为位置参数提供。
   - 关键字参数由正则表达式匹配的任何命名组组成，由可选 kwargs 参数 中指定的任何参数覆盖。`django.urls.path()`、`django.urls.re_path()`。
5. 如果没有正则表达式匹配，或者在此过程中的任何一点出现异常，Django 将调用适当的错误处理视图。

**2.路由示例代码**

以下是一个路由与视图的示例: `myapp/urls.py`如下:

```python
from django.urls import path, re_path
from myapp import views

urlpatterns = [
    path("", views.index, name='index'),
    path('index/', views.index, name='index'),
    path("articles/2003/", views.special_case_2003, name="special_case_2003"),
    path("articles/<int:year>/", views.year_archive, name="year_archive"),
    path("articles/<int:year>/<int:month>/", views.month_archive, name="month_archive"),
    path("articles/<int:year>/<int:month>/<slug:slug>/", views.article_detail, name="article_detail"),
    re_path(r' ^find/(?P<year>[0-9]{4})/$ ', views.find, name='find'),
    re_path(r' ^add/([0-9]{2})/$ ', views.add, name='add')
]

```

对应的`myapp/views.py`文件

```python
from django.shortcuts import render
from django.http import HttpResponse


# Create your views here.
def index(request):
    return HttpResponse('index首页')


def special_case_2003(request):
    return HttpResponse("special_case_2003")


def year_archive(request, year=0):
    return HttpResponse("year_archive 年份:%s" % year)


def month_archive(request, year=0, month=0):
    return HttpResponse("year_archive 年份:%s,月份:%s" % (year, month))


def article_detail(request, year=0, month=0, slug=""):
    return HttpResponse("article_detail 年份:%s,月份:%s,后缀%s" % (year, month, slug))


def find(request, year):
    return HttpResponse(f'find函数 年份: {year}')


def add(request, mm):
    return HttpResponse(f'add函数{mm}')
```

说明：

- 要从 URL 捕获一个值，请使用尖括号括起来。(路径转换器)
- 捕获的值可以选择包括转换器类型。例如，用于 `<int:name>` ( <数据类型 : 变量名称> ) 捕获整数参数。如果不包括转换器`/`，则匹配除字符以外的任何字符串。
- 无需添加斜杠，因为每个 URL 都有该斜杠。例如`articles`，不是/`articles`。

**3.路径转换器**

- 默认情况下，以下路径转换器可用：
  - `str`-匹配任何非空字符串，但路径分隔符除外'/'。如果表达式中不包含转换器，则为默认设置。
  - `int`-匹配零或任何正整数。返回一个 int。
  - `slug`-匹配由 ASCII 字母或数字以及连字符和下划线字符组成的任何条形字符串。例如， `building-your-1st-django-site`。
  - `uuid`-匹配格式化的 UUID。为防止多个 URL 映射到同一页面，必须包含破折号并且字母必须小写。例如，075194d3-6885-417e-a8a8-6c931e272f00。返回一个 UUID 实例。
  - `path`-匹配任何非空字符串，包括路径分隔符 '/'。这样，您就可以匹配完整的 URL 路径，而不是像一样匹配 URL 路径的一部分 str。

**4.通过浏览器访问服务**

注意：url 路由，由上而下 进行匹配，如果在上面就匹配成功，则不会向下匹配

```python
# 通过浏览器访问服务的基本过程:
    127.0.0.1:8000/abc
        ==>  root url(根路由)
        ==> 加载子路由（myweb/urls.py）
    	==> 正则匹配访问的路径(path)
        ==> 视图函数(views.index)
    	==> views.py ,index() 响应内容
```

**5.使用正则表达式:**

- 如果路径和转换器语法不足以定义 URL 模式，则还可以使用正则表达式。为此，请使用`re_path()`代替`path()`。
- 在 Python 正则表达式中，命名正则表达式组的语法为`(?P<name>pattern)`,其中`name`是组的名称，并且 pattern 是匹配的某种模式。
- 这是前面的示例路由文件，使用正则表达式重写`urls.py`：

```python
from django.urls import path, re_path

from . import views

urlpatterns = [
    path("articles/2003/", views.special_case_2003, name="special_case_2003"),
    re_path(r"^articles/(?P<year>[0-9]{4})/$", views.year_archive, name="year_archive"),
    re_path(r"^articles/(?P<year>[0-9]{4})/(?P<month>[0-9]{2})/$", views.month_archive, name="month_archive"),
    re_path(r"^articles/(?P<year>[0-9]{4})/(?P<month>[0-9]{2})/(?P<slug>[\w-]+)/$", views.article_detail, name="article_detail"),
]

'''
[]	匹配括号中的任意一个字符
+	紧跟在它前面的单元,应匹配一次或多次
\w	==	[a-zA-Z0-9] 数字字母下划线
'''
```

- 这可以完成与上一个示例大致相同的操作，除了：
  - 将要匹配的确切 URL 受到更多限制。例如，年份 10000 将不再匹配，因为年份整数被限制为正好是四位数长。
  - 无论正则表达式进行哪种匹配，每个捕获的参数都将作为 字符串 发送到视图。
- 当从使用切换为使用 path()，re_path()反之亦然时，特别重要的是要注意视图参数的类型可能会更改，因此您可能需要调整视图。

**使用未命名的正则表达式组(不推荐)**

- 除了命名组语法（例如）之外`(?P<year>[0-9]{4})`，您还可以使用较短的未命名组（例如）`([0-9]{4})`。
- 不建议特别使用此用法，因为这样可以更轻松地在匹配的预期含义和视图的参数之间意外引入错误。
- 无论哪种情况，建议在给定的正则表达式中仅使用一种样式。当两种样式混合使用时，任何未命名的组都会被忽略，只有命名的组才会传递到视图函数。

**为视图参数指定默认值**

- 一个方便的技巧是为视图的参数指定默认参数。这是一个示例路由和视图：

```python
# urls.py
from django.urls import path
from . import views

urlpatterns = [
    path('blog/', views.page),
    path('blog/page<int:num>/', views.page),
]

# views.py
def page(request, num=1):
    ...
   	pass
```

- 在上面的示例中，两个 URL 模式都指向同一视图`views.page`但是第一个模式未捕获 URL 中的任何内容。
- 如果第一个模式匹配，该 page()函数将使用它的默认参数`num=1`。
- 如果第二个模式匹配， page()将使用 num 捕获的任何值。

### 2.4 404 错误处理

当 Django 找不到与请求的 URL 匹配的正则表达式时，或者异常引发时，Django 将调用错误处理视图。

**关于 404 错误**

- 404 的错误页面，在`template文件夹目录`中创建一个 404.html 的页面，

- 在配置文件中 settings.py 配置 DEBUG = False

- 在配置文件中 settings.py 配置 TEMPLATES = 'DIRS': [os.path.join(BASE_DIR, 'templates')],

- ```py
  DEBUG = False

  TEMPLATES = {
      'DIRS': [os.path.join(BASE_DIR, 'templates')]
  },
  ```

- 同时需要在项目的根目录下创建文件夹`templates`，并且在此目录下创建一个`404.html`文件

- 在出现 404 的情况时，自动寻找 404 页面。

- 也可以在视图函数中 手动报出 404 错误，带提醒信息

在视图函数中也可以指定返回一个 404

```python
注意 Http404需要在django.http的模块中引入

from django.http import Http404

 # 响应404
 raise Http404('404,页面不存在')  # raise主动抛出异常
```

在模板中 `404.html`

```python
<!DOCTYPE html>
<html>
<head>
    <title>404</title>
</head>
<body>
    <center>
        <h2>404 页面不存在!</h2>
        <h3>请检查是否输出了正确的响应地址</h3>
    </center>
</body>
</html>
```

### 2.5 抽离应用程序路由

在任何时候，您`urlpatterns`都可以“包含”其他 路由文件 模块。

例如，

```python
from django.urls import include, path

# 根路由的使用方式
urlpatterns = [
    # ...
    path('community/', include('aggregator.urls')),
    path('contact/', include('contact.urls')),
    # ...
]
```

- 每当 Django 遇到`include()`时，它都会截断直到该时间点匹配的 URL 的任何部分，并将剩余的字符串发送到包含的 路由文件 中以进行进一步处理。

### 2.6 URL 的反向解析

如果在视图、模板中使用硬编码的链接，在路由发生改变时，维护是一件非常麻烦的事情。

- 解决：在做链接时，通过指向 路由文件 的名称，动态生成链接地址。
- 视图：使用 reverse()函数
- 模板：使用 url 模板标签

**示例**

- 在 urls.py 路由文件中

```python
# myapp/urls.py 创建子路由文件
from django.urls import path
from . import views

urlpatterns = [
    path('', views.index, name='index'),
    path('stu/', views.stu, name='stu'),
]
```

- 在 views.py 视图文件中：

```python
# myapp/views.py
from django.http import HttpResponse
from django.urls import reverse


def index(request):
    print(reverse('stu'))   # 反解析 /stu/
    return HttpResponse(reverse('stu'))


def stu(request):
    return HttpResponse('查询数据库成功!')
```

### 2.7 路由重定向

直接使用`redirect` 进行跳转

```python
# myapp/views.py

from django.http import HttpResponse
from django.urls import reverse
from django.shortcuts import redirect


def index(request):
    return redirect(reverse('add', args=(10,)))  # 路由重定向


def stu(request):
    return HttpResponse('Stu')


def add(request, number):
    return HttpResponse(f'add! 添加的数字:{number}')

```

然后在 myapp/urls.py 中加一条路由规则

```python
# myapp/urls.py
# 创建子路由文件

from django.urls import path
from . import views

urlpatterns = [
    path('', views.index, name='index'),
    path('stu/', views.stu, name='stu'),
    path('add/<int:number>', views.add, name='add'),
]
```

## 3. Django 的模型层

### 3.1Model 模型

模型是你的数据的唯一的、权威的信息源。它包含你所储存数据的必要 字段 和 行为 。

通常，每个模型对应数据库中唯一的一张表，每个属性对应一个字段。

- 每个模型都是`django.db.models.Model`的一个 Python 子类。
- 模型的每个属性都表示为数据库中的一个字段。
- Django 提供一套自动生成的用于数据库访问的 API；

![image-20220906150641464](http://mk.xxoutman.cn/django/image-20220906150641464.png)

**1.模型与数据库的关系**

模型与数据库的关系是 ORM 关系 ( 对象-关系-映射 ) ，主要任务是：

- 根据对象的类型生成表结构
- 将对象、列表的操作，转换为 sql 语句
- 将 sql 查询到的结果转换为对象、列表

**2.为什么要用模型?**

Model 是 MVC 框架中重要的一部分,主要负责程序中用于处理数据逻辑的部分。通常模型对象负责在数据库中存取数据。

它实现了数据模型与数据库的解耦，即数据模型的设计不需要依赖于特定的数据库，通过简单的配置就可以轻松更换数据库。

### 3.2Model 模型实战

#### 1.创建项目与应用

```py
# 创建项目
django-admin startproject mydemo

# 创建一个应用程序
python manage.py startapp myapp

#在项目根目录,创建模板目录
templates

#在template文件夹创建一个文件夹,用于存放应用程序myapp的模板
myapp
```

#### 2.执行数据库连接配置，网站配置

1.使用的 MySQL 数据库是: `mysite` 数据库

2.修改`mydemo/settings.py`的配置文件

```py
ALLOWED_HOSTS = ['*']

INSTALLED_APPS = [
    'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.messages',
    'django.contrib.staticfiles',
    'myapp'
]

TEMPLATES = [
    {
        'DIRS': [os.path.join(BASE_DIR, 'template')],
    }
]

DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.mysql',
        'NAME': 'mysite',  # 数据库名称
        'USER': 'root',  # 用户名
        'PASSWORD': 'root',  # 密码
        'HOST': 'localhost',
        'PORT': '3306',
    }
}

USE_TZ = False
```

3.在`myapp/models.py`中定义模型类，要求继承自**models.Model 类**

```python
from django.db import models
from datetime import datetime

class Users(models.Model):
   id = models.AutoField(primary_key=True)  # 主键可省略不写
   name = models.CharField(max_length=32)
   age = models.IntegerField(default=20)
   phone = models.CharField(max_length=16)
   addtime=models.DateTimeField(default=datetime.now)

    #class Meta:
    #  指定表名，如果没有写，默认表名称: myapp_users。
    #  db_table = "myapp_users"
```

4.生成迁移文件 ( 相当于”生成 sql 语句脚本。)

```python
python manage.py makemigrations
```

5.执行迁移 ( 相当于在数据库里面创建数据库表 )

```python
python manage.py migrate
```

6.使用模型类进行 crud 操作

`myapp/views.py`

```py
from django.shortcuts import render
from django.http import HttpResponse

from myapp.models import Users


# 视图层
def index(request):
    # 执行Model的操作

    # 添加操作
    # ob = Users()  # 实例化一个Users模型
    # ob.name = "李四"
    # ob.age = 26
    # ob.phone = '123456789'
    # ob.save()  # 保存数据
    # 或者
	# user = Users(name='张三', age=18, phone='123456789')
    # user.save()  # 保存数据

    # 或者
    # Users.objects.create(name='李四', age=33, phone='987635241')

    #批量添加数据
    '''
    datas = [
        {'name': '剑豪', 'age': 66, 'phone': '555555'},
        {'name': '厄运小姐', 'age': 26, 'phone': '777777'},
    ]

    for item in datas:
        Users.objects.create(
            name=item['name'],
            age=item['age'],
            phone=item['phone']
        )
    '''

    # 删除操作
    # mod = Users.objects  # 获取users的model对象
    # user = mod.get(id=3)  # 获取id值为6的数据信息
    # print(user.name)
    # user.delete()

    # 修改操作
    # ob = Users.objects.get(id=2)
    # print(ob.name)
    # ob.name = "小刘"
    # ob.age = 99
    # ob.save()  # 保存数据

    # 或者
    # 修改数据 先查询name='张三丰'的数据把他的age修改成44
    # res = Users.objects.filter(name='张三丰').update(age=44)
    # print(res) # res 返回影响的行数


    # 查询数据
    # mod = Users.objects  # 获取users模型的Model操作对象

    # ulist = mod.all()  # 获取所有数据
    # ulist = mod.filter(name='小刘')  # 获取name值为小刘的信息
    # ulist = mod.filter(age__gt=20)  # 获取所有age>20的信息
    # ulist = mod.filter(age__gte=20)  # 扶取所有age>=20的信息
    # ulist = mod.filter(age__lt=20)  # 获取所有age<20的信息
    # ulist = mod.filter(age__lte=20)  # 获取所有age<=20的信息
    # ulist = mod.order_by("age")  # 按age升序排序
    # ulist = mod.order_by("age")[:2]  # 按age升序排序，只获取前2条
    #
    # for u in ulist:
    #     print(u.id, u.name, u.age, u.addtime)

    return HttpResponse('首页')
```

### 3.3 定义模型

**1.定义模型**

- 在模型中定义属性，会生成表中的字段
- django 会为表创建自动增长的主键列，每个模型只能有一个主键列，如果使用选项设置某属性为主键列后，则 django 不会再生成默认的主键列
- 属性命名限制
  - 不能是 python 的保留关键字
  - 由于 django 的查询方式，不允许使用连续的下划线

**2.字段类型**

- AutoField
- 一个根据实际 ID 自动增长的 IntegerField，通常不指定

  - 如果不指定，一个主键字段将自动添加到模型中

- BooleanField：true/false 字段，此字段的默认表单控制是 CheckboxInput

- NullBooleanField：支持 null、true、false 三种值

- CharField(max_length=字符长度)：字符串，默认的表单样式是 TextInput

- TextField：大文本字段，一般超过 4000 使用，默认的表单控件是 Textarea

- IntegerField：整数

- DecimalField(max_digits=None, decimal_places=None)：使用 python 的 Decimal 实例表示的十进制浮点数

  - DecimalField.max_digits：位数总数
  - DecimalField.decimal_places：小数点后的数字位数

- FloatField：用 Python 的 float 实例来表示的浮点数

- DateField[auto_now=False, auto_now_add=False])：使用 Python 的 datetime.date 实例表示的日期

  - 参数 DateField.auto_now：每次保存对象时，自动设置该字段为当前时间，用于"最后一次修改"的时间戳，它总是使用当前日期，默认为 false
  - 参数 DateField.auto_now_add：当对象第一次被创建时自动设置当前时间，用于创建的时间戳，它总是使用当前日期，默认为 false
  - 该字段默认对应的表单控件是一个 TextInput. 在管理员站点添加了一个 JavaScript 写的日历控件，和一个“Today"的快捷按钮，包含了一个额外的 invalid_date 错误消息键
  - auto_now_add, auto_now, and default 这些设置是相互排斥的，他们之间的任何组合将会发生错误的结果

- TimeField：使用 Python 的 datetime.time 实例表示的时间，参数同 DateField

- DateTimeField：使用 Python 的 datetime.datetime 实例表示的日期和时间，参数同 DateField

- FileField：一个上传文件的字段

- ImageField：继承了 FileField 的所有属性和方法，但对上传的对象进行校验，确保它是个有效的 image

**3.字段选项**

- 通过字段选项，可以实现对字段的约束，在字段对象中通过关键字参数指定。
- null：如果为 True，Django 将空值以 NULL 存储到数据库中，默认值是 False
- blank：如果为 True，则该字段允许为空白，默认值是 False
- db_column：字段的名称，如果未指定，则使用属性的名称
- db_index：若值为 True, 则在表中会为此字段创建索引
- default：默认值
- primary_key：若为 True, 则该字段会成为模型的主键字段
- unique：如果为 True, 这个字段在表中必须有唯一值

**4.字段关系**

- 关系的类型包括
  - ForeignKey：一对多，将字段定义在多的端中
  - ManyToManyField：多对多，将字段定义在两端中
  - OneToOneField：一对一，将字段定义在任意一端中

**5.元选项**

- 在模型类中定义类 Meta，用于设置元信息，

- 元信息 db_table：定义数据表名称，推荐使用小写字母，

- 数据表的默认名称:<app*name>*<model_name>

- 例如 myweb_users

- ordering：对象的默认排序字段，获取对象的列表时使用，接收属性构成的列表

- ```py
  class BookInfo(models.Model):
      ...
      class Meta():
          ordering = ['id']
  ```

- 字符串前 加- 表示倒序，不加- 表示正序。

  ```python
  class BookInfo(models.Model):
      ...
      class Meta():
          ordering = ['-id']
  ```

- 排序会增加数据库的开销

### 3.4 模型实例

**1. 类的属性**

- `objects`：是 Manager 类型的对象，用于与数据库进行交互

**2. 创建对象**

- 当创建对象时，django 不会对数据库进行读写操作。
- 调用`save()`方法才与数据库交互，将对象保存到数据库中。

**3. 实例的属性**

- DoesNotExist：在进行单个查询时，模型的对象不存在时会引发此异常，结合 try / except 使用。

**4. 实例的方法**

- `__str__(self)`：重写 object 方法，此方法在将对象转换成字符串时会被调用。
- save()：将模型对象保存到数据表中。
- delete()：将模型对象从数据表中删除。

### 3.5 模型查询

查找 是数据库操作中一个非常重要的技术。查询一般就是使用`filter`、`exclude`以及`get`三个方法来实现。我们可以在调用这些方法的时候传递不同的参数来实现查询需求。在`ORM`层面，这些查询条件都是使用`field`+`__`+`condition`的方式来使用的。以下将那些常用的查询条件来一一解释。

#### 1.基本查询方法

1. exact：

使用精确的`=`进行查找。如果提供的是一个`None`，那么在`SQL`层面就是被解释为`NULL`。示例代码如下：

```py
article = Article.objects.get(id__exact=14)
article = Article.objects.get(id__exact=None)
```

以上的两个查找在翻译为`SQL`语句为如下：

```py
select ... from article where id=14;
select ... from article where id IS NULL;
```

2. iexact：

使用`like`进行查找。示例代码如下：

```python
article = Article.objects.filter(title__iexact='hello world')
```

那么以上的查询就等价于以下的`SQL`语句：

```python
select ... from article where title like 'hello world';
```

注意上面这个`sql`语句，因为在`MySQL`中，没有一个叫做`ilike`的。所以`exact`和`iexact`的区别实际上就是`LIKE`和`=`的区别，在大部分`collation=utf8_general_ci`情况下都是一样的（`collation`是用来对字符串比较的）。

3. contains：

大小写敏感，判断某个字段是否包含了某个数据。示例代码如下：

```py
articles = Article.objects.filter(title__contains='hello')
```

在翻译成`SQL`语句为如下：

```py
select ... where title like binary '%hello%';
```

要注意的是，在使用`contains`的时候，翻译成的`sql`语句左右两边是有百分号的，意味着使用的是模糊查询。而`exact`翻译成`sql`语句左右两边是没有百分号的，意味着使用的是精确的查询。

4. icontains：

大小写不敏感的匹配查询。示例代码如下：

```py
articles = Article.objects.filter(title__icontains='hello')
```

在翻译成`SQL`语句为如下：

```py
select ... where title like '%hello%';
```

5. in：

提取那些给定的`field`的值是否在给定的容器中。容器可以为`list`、`tuple`或者任何一个可以迭代的对象，包括`QuerySet`对象。示例代码如下：

```py
articles = Article.objects.filter(id__in=[1,2,3])
```

以上代码在翻译成`SQL`语句为如下：

```py
select ... where id in (1,3,4)
```

6. gt：

某个`field`的值要大于给定的值。示例代码如下：

```py
articles = Article.objects.filter(id__gt=4)
```

以上代码的意思是将所有`id`大于 4 的文章全部都找出来。
将翻译成以下`SQL`语句：

```py
select ... where id > 4;
```

7. gte：

类似于`gt`，是大于等于。

8. lt：

类似于`gt`是小于。

9. lte：

类似于`lt`，是小于等于。

10. startswith：

判断某个字段的值是否是以某个值开始的。大小写敏感。示例代码如下：

```py
articles = Article.objects.filter(title__startswith='hello')
```

以上代码的意思是提取所有标题以`hello`字符串开头的文章。
将翻译成以下`SQL`语句：

```py
select ... where title like 'hello%'
```

11. istartswith：

类似于`startswith`，但是大小写是不敏感的。

12. endswith：

判断某个字段的值是否以某个值结束。大小写敏感。示例代码如下：

```python
articles = Article.objects.filter(title__endswith='world')
```

以上代码的意思是提取所有标题以`world`结尾的文章。
将翻译成以下`SQL`语句：

```py
select ... where title like '%world';
```

13. iendswith：

类似于`endswith`，只不过大小写不敏感。

14. isnull：

根据值是否为空进行查找。示例代码如下：

```py
articles = Article.objects.filter(pub_date__isnull=False)
```

以上的代码的意思是获取所有发布日期不为空的文章。
将来翻译成`SQL`语句如下：

```py
select ... where pub_date is not null;
```

15. 限制查询集

- 查询集返回列表，可以使用下标的方式进行限制，等同于 sql 中的`limit`和`offset`子句

- 注意：不支持负数索引

- 使用下标后返回一个新的查询集，不会立即执行查询

- 如果获取一个对象，直接使用[0]，等同于[0:1].get()，但是如果没有数据，[0]引发 IndexError 异常，[0:1].get()引发 DoesNotExist 异常

  ```python
  #这会返回前5个对象 LIMIT 5
  Entry.objects.all()[:5]
  #这将返回第六个到第十个对象 OFFSET 5 LIMIT 5
  Entry.objects.all()[5:10]
  ```

16. year、month、day、week_day、hour、minute、second：对日期间类型的属性进行运算

```py
filter(bpub_date__year=1980)
filter(bpub_date__gt=date(1980, 12, 31))
```

#### 2.聚合函数：

如果你用原生`SQL`，则可以使用聚合函数来提取数据。比如提取某个商品销售的数量，那么可以使用`Count`，如果想要知道商品销售的平均价格，那么可以使用`Avg`。
聚合函数是通过`aggregate`方法来实现的。在讲解这些聚合函数的用法的时候，都是基于以下的模型对象来实现的。

```py
from django.db import models

class Author(models.Model):
	"""作者模型"""
	name = models.CharField(max_length=100)
	age = models.IntegerField()
	email = models.EmailField()

	class Meta:
		db_table = 'author'


class Publisher(models.Model):
	"""出版社模型"""
	name = models.CharField(max_length=300)

	class Meta:
		db_table = 'publisher'


class Book(models.Model):
	"""图书模型"""
	name = models.CharField(max_length=300)
	pages = models.IntegerField()
	price = models.FloatField()
	rating = models.FloatField()
	author = models.ForeignKey(Author,on_delete=models.CASCADE)
	publisher = models.ForeignKey(Publisher, on_delete=models.CASCADE)

	class Meta:
		db_table = 'book'


class BookOrder(models.Model):
	"""图书订单模型"""
	book = models.ForeignKey("Book",on_delete=models.CASCADE)
	price = models.FloatField()

	class Meta:
		db_table = 'book_order'
```

1. `Avg`：求平均值。比如想要获取所有图书的价格平均值。那么可以使用以下代码实现。

   ```py
   from django.db.models import Avg
   result = Book.objects.aggregate(Avg('price'))
   print(result)
   ```

   以上的打印结果是：

   ```py
   {"price__avg":23.0}
   ```

   其中`price__avg`的结构是根据`field__avg`规则构成的。如果想要修改默认的名字，那么可以将`Avg`赋值给一个关键字参数。示例代码如下：

   ```py
   from django.db.models import Avg
   result = Book.objects.aggregate(my_avg=Avg('price'))
   print(result)
   ```

   那么以上的结果打印为：

   ```py
   {"my_avg":23}
   ```

2. `Count`：获取指定的对象的个数。示例代码如下：

   ```py
   from django.db.models import Count
   result = Book.objects.aggregate(book_num=Count('id'))
   ```

   以上的`result`将返回`Book`表中总共有多少本图书。
   `Count`类中，还有另外一个参数叫做`distinct`，默认是等于`False`，如果是等于`True`，那么将去掉那些重复的值。比如要获取作者表中所有的不重复的邮箱总共有多少个，那么可以通过以下代码来实现：

   ```py
   from django.db.models import Count
   result = Author.objects.aggregate(count=Count('email',distinct=True))
   ```

3. `Max`和`Min`：获取指定对象的最大值和最小值。比如想要获取`Author`表中，最大的年龄和最小的年龄分别是多少。那么可以通过以下代码来实现：

   ```py
   from django.db.models import Max,Min
   result = Author.objects.aggregate(Max('age'),Min('age'))
   ```

   如果最大的年龄是 88,最小的年龄是 18。那么以上的 result 将为：

   ```
   {"age__max":88,"age__min":18}
   ```

4. `Sum`：求指定对象的总和。比如要求图书的销售总额。那么可以使用以下代码实现：

   ```py
   from django.db.models import Sum
   result = obj = Stu.objects.aggregate(total=Sum('age')) # {'total': 40}
   ```

### 3.6 用户信息管理实战

新建一个项目 Project `django-admin startproject Project`

创建一个应用程序 User `python manage.py startapp User `

编写 子路由 与 根路由 和 视图函数 把项目跑起来

在`settings.py`里面配置

```python
ALLOWED_HOSTS = ["*"] #允许所有的域名进行访问

INSTALLED_APPS=[
	...
    User  #加载应用程序
]
"DIRS": [os.path.join(BASE_DIR, "templates")],  #配置模板的文件路径

#数据库连接 需要自己创建一个User数据库
"default": {
   "ENGINE": "django.db.backends.mysql",
    "NAME": "user",
    "USER": "root",
    "PASSWORD": "root",
    "HOST": "localhost",
     "PORT": "3306",
}
```

在`User/models.py`文件里面配置模型

```python
# User 模型层
from django.db import models
from datetime import datetime


# User 模型层
class User(models.Model):
    id = models.AutoField(primary_key=True)  # 主键可省略不写
    name = models.CharField(max_length=32)
    age = models.IntegerField(default=20)
    phone = models.CharField(max_length=16)
    addtime = models.DateTimeField(default=datetime.now)

    class Meta:
        db_table = 'user'  # 设置表名
```

然后生成迁移文件`python manage.py makemigrations`

执行迁移文件`python manage.py migrate`

就会在数据库创建数据库表。检测数据库是否可以正常使用

在`User/views.py`书写逻辑

```python
from django.shortcuts import render
from django.http import HttpResponse
from User.models import User

# 视图函数
def index(request):
    mod = User.objects  # 获取User的一个模型对象
    ulist = mod.all()  # 获取所有数据
    for u in ulist:
        print(u.id, u.name, u.age, u.addtime)
    return HttpResponse("首页")
	# return HttpResponse("<center><h1>用户主页</h1> <a href='/indexUsers'>学生管理系统</a> </center>")
```

下面在`User/views.py`里面写业务逻辑

```python
# 浏览用户信息
def indexUsers(request):
    try:
        ulist = User.objects.all()  # 获取所有用户信息
        context = {"ulist": ulist}
        return render(request, "User/index.html", context)  # 加载模板
    except:
        return HttpResponse("没有找到用户信息!")

# 加载添加用户信息表单
def addUsers(request):
    return render(request, "User/add.html")  # 加载模板

# 执行用户信息添加
def insertUsers(request):
    try:
        ob = User()  # 从表单中获取要添加的信息并封装到ob对象中
        ob.name = request.POST["name"]
        ob.age = request.POST["age"]
        ob.phone = request.POST["phone"]
        ob.save()  # 执行保存操作
        context = {"info": "添加成功!"}
    except:
        context = {"info": "添加失败!"}

    return render(request, "User/info.html", context)

# 执行用户信息删除
def delUsers(request, uid=0):
    try:
        ob = User.objects.get(id=uid)  # 获取要删除的数据
        ob.delete()  # 执行删除操作
        context = {"info": "删除成功!"}
    except:
        context = {"info": "删除失败!"}

    return render(request, "User/info.html", context)

# 加载用户信息修改表单
def editUsers(request, uid=0):
    try:
        ob = User.objects.get(id=uid)  # 获取要修改的数据
        context = {"user": ob}
    except:
        context = {"info": "没有找到要修改的数据!"}

    return render(request, "User/edit.html", context)

# 执行用户信息修改
def updateUsers(request):
    try:
        uid = request.POST["id"]
        ob = User.objects.get(id=uid)  # 获取要修改的数据
        ob.name = request.POST["name"]
        ob.age = request.POST["age"]
        ob.phone = request.POST["phone"]
        ob.save()  # 执行保存
        context = {"info": "修改成功"}
    except:
        context = {"info": "没有找到要修改的数据!"}

    return render(request, "User/info.html", context)
```

`User/urls.py`文件:

```python
from unicodedata import name
from django.urls import path
from . import views

# 配置子路由
urlpatterns = [
    path("", views.index, name="index"),
    path("indexUsers", views.indexUsers, name="indexUsers"),
    path("addUsers", views.addUsers, name="addUsers"),
    path("insertUsers", views.insertUsers, name="insertUsers"),
    path("delUsers/<int:uid>", views.delUsers, name="delUsers"),
    path("editUsers/<int:uid>", views.editUsers, name="editUsers"),
    path("updateUsers", views.updateUsers, name="updateUsers"),
]
```

在`templates`里面创建一个文件夹`User`用于存放模板 html 文件

#### `index.html`

```python
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>Title</title>
    <script></script>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.6.1/dist/css/bootstrap.min.css" />

    <style>
      body {
        width: 1000px;
        text-align: center;
        margin: 0 auto;
      }
      button {
        margin: 5px 0;
      }
    </style>
  </head>
  <body>
    <h1 class="display-4">用户信息管理系统</h1>
    <a href="{% url 'indexUsers' %}"><button type="button" class="btn btn-primary">浏览信息</button></a>
    <a href="{% url 'addUsers' %}"> <button type="button" class="btn btn-danger">添加信息</button></a>
    <hr />

    <table class="table table-hover table-striped">
      <thead>
        <tr>
          <th>ID号</th>
          <th>姓名</th>
          <th>年龄</th>
          <th>电话</th>
          <th>添加时间</th>
          <th>操作</th>
        </tr>
      </thead>
      <tbody>
        {% for user in ulist %}
        <tr>
          <td scope="row">{{user.id}}</td>
          <td>{{user.name}}</td>
          <td>{{user.age}}</td>
          <td>{{user.phone}}</td>
          <td>{{user.addtime}}</td>
          <td>
            <a href="{% url 'editUsers' user.id %}"><button type="button" class="btn btn-info btn-sm">编辑</button></a>
            <a href="{% url 'delUsers' user.id %}"><button type="button" class="btn btn-warning btn-sm">删除</button></a>
          </td>
        </tr>
        {% endfor %}
      </tbody>
    </table>
  </body>
</html>
```

#### `add.html`

```python
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.6.1/dist/css/bootstrap.min.css" />

    <style>
      body {
        width: 1000px;
        text-align: center;
        margin: 0 auto;
      }
      button {
        margin: 5px 0;
      }
    </style>
  </head>
  <body>
    <h1 class="display-4">用户信息管理系统</h1>
    <a href="{% url 'indexUsers' %}"><button type="button" class="btn btn-primary">浏览信息</button></a>
    <a href="{% url 'addUsers' %}"> <button type="button" class="btn btn-danger">添加信息</button></a>
    <hr />
    <h3>添加用户信息</h3>
    <form action="{% url 'insertUsers' %}" method="post">
      {% csrf_token %}
      <div class="form-group row">
        <label for="name" class="col-sm-2">性别: </label>
        <div class="col-sm-10">
          <input type="text" class="form-control" id="name" name="name" />
        </div>
      </div>
      <div class="form-group row">
        <label for="age" class="col-sm-2">年龄: </label>
        <div class="col-sm-10">
          <input type="text" class="form-control" id="age" name="age" />
        </div>
      </div>
      <div class="form-group row">
        <label for="phone" class="col-sm-2">电话: </label>
        <div class="col-sm-10">
          <input type="text" class="form-control" id="phone" name="phone" />
        </div>
      </div>

      <button type="submit" class="btn btn-primary">添加</button>
      <button type="resize" class="btn btn-danger">重置</button>
    </form>
  </body>
</html>
```

#### `info.html`

```python
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.6.1/dist/css/bootstrap.min.css" />

    <style>
      body {
        width: 1000px;
        text-align: center;
        margin: 0 auto;
      }
      button {
        margin: 5px 0;
      }
    </style>
  </head>
  <body>
    <h1 class="display-4">用户信息管理系统</h1>
    <a href="{% url 'indexUsers' %}"><button type="button" class="btn btn-primary">浏览信息</button></a>
    <a href="{% url 'addUsers' %}"> <button type="button" class="btn btn-danger">添加信息</button></a>
    <hr />

    <h3>操作提示信息</h3>
    <h4 class="display-5" style="color: red">{{info}}</h4>
  </body>
</html>
```

#### `edit.html`

```python
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.6.1/dist/css/bootstrap.min.css" />

    <style>
      body {
        width: 1000px;
        text-align: center;
        margin: 0 auto;
      }
      button {
        margin: 5px 0;
      }
    </style>
  </head>
  <body>
    <h1 class="display-4">用户信息管理系统</h1>
    <a href="{% url 'indexUsers' %}"><button type="button" class="btn btn-primary">浏览信息</button></a>
    <a href="{% url 'addUsers' %}"> <button type="button" class="btn btn-danger">添加信息</button></a>
    <hr />
    <h3>修改用户信息</h3>
    <form action="{% url 'updateUsers' %}" method="post">
      {% csrf_token %}
      <!-- id行 -->
      <input type="hidden" name="id" value="{{user.id}}" />

      <div class="form-group row">
        <label for="name" class="col-sm-2">姓名: </label>
        <div class="col-sm-10">
          <input type="text" class="form-control" id="name" name="name" value="{{user.name}}" />
        </div>
      </div>
      <div class="form-group row">
        <label for="age" class="col-sm-2">年龄: </label>
        <div class="col-sm-10">
          <input type="text" class="form-control" id="age" name="age" value="{{user.age}}" />
        </div>
      </div>
      <div class="form-group row">
        <label for="phone" class="col-sm-2">电话: </label>
        <div class="col-sm-10">
          <input type="text" class="form-control" id="phone" name="phone" value="{{user.phone}}" />
        </div>
      </div>

      <button type="submit" class="btn btn-primary">修改</button>
      <button type="resize" class="btn btn-danger">重置</button>
    </form>
  </body>
</html>
```

## 4. Django 的视图层

**Django 的视图层介绍 :**

Django 框架中的视图（View）是用来负责处理 用户请求 和 返回响应 的逻辑程序。

视图（View）简而言之就是一个 Python 的函数或方法，接受处理 Web 请求。

视图的响应可以是网页的 HTML 内容，重定向 或 404 错误，XML 文档 或 图像。

视图的代码按惯例是放置一个名为`views.py`的文件中，此文件放在项目或应用程序目录中。（其实视图文件名可以自己定义）。

下面就开始学习视图层相关内容:

创建一个 myweb 的项目: `django-admin startproject myweb`

cd 到 myweb 文件夹里面去,

创建一个 polls 的应用程序: `python manage.py startapp polls`

来到`settings.py 写网站配置选项`

```py
ALLOWED_HOSTS = ['*']

'DIRS': [os.path.join(BASE_DIR, 'templates')],
```

### 4.1 一个简单的视图

这是一个返回当前日期和时间的视图，作为 HTML 文档：

```python
from django.shortcuts import render
from django.http import HttpResponse
from datetime import datetime

# 渲染一个模板
def index(request):
    return render(request, 'polls/index.html')

def time(request):
    now = datetime.now()  # 读取的是 系统的本地时间 2020-02-09 23:27:42.420705
    # Python内置的strftime()函数：实现本地时间或者日期的格式化。
    # %Y	四个数字表示的年份 2015
    # %m	返回月份 范围[0,12]
    # %d	返回的是当前时间是当前月的第几天
    # %H	以24小时制表示当前小时
    # %M	返回分钟数 范围 [0,59]
    # %S	返回秒数 范围 [0,61]。。。手册说明的
    html = f'当前时间是: {now.strftime("%Y-%m-%d %H:%M:%S")}'
    return HttpResponse(html)
```

### 4.2 返回错误

```python
from django.http import HttpResponse, Http404, HttpResponseNotFound

def error404(request):
    # 直接返回一个404,没有去加载404的模板页面
    return HttpResponseNotFound('<h1>页面没有找到</h1>')

    # 可以直接返回一个status状态码
    # return HttpResponse(status=403)

    # 返回一个404的错误页面
    # raise Http404("我是一个错误页面")
```

### 4.3 关于重定向

重定向( `redirect` )就是通过各种方法将各种网络请求重新定个方向转到其它位置

```python
from django.shortcuts import redirect
from django.urls import reverse


# return redirect(reverse('userindex'))
def redir(request):
    # redirect重定向  reverse反向解析url地址
    return redirect(reverse('time'))

    # 执行一段js代码，用js进行重定向
    # return HttpResponse('<script>alert("添加成功");location.href = "/userindex"; </script>')
```

### 4.4 基于类的基本视图：

示例`views.py`：

```python
from django.shortcuts import render
from django.http import HttpResponse
from django.views import View


class MyView(View):
    """类视图：处理注册"""

    def get(self, request):
        """处理GET请求，返回注册页面"""
        return render(request, 'app/index.html')

    def post(self, request):
        """处理POST请求，实现注册逻辑"""
        return HttpResponse('这里实现注册逻辑')


def home(request):
    if request.method == 'GET':
        return HttpResponse('get请求')
    elif request.method == 'POST':
        return HttpResponse('post请求')

```

示例`urls.py`：

```python
from django.urls import path, include
from app.views import MyView
from app import views

urlpatterns = [
    path('', MyView.as_view(), name='myview'),
    path('home/', views.home, name='home'),
]


# 其中as_view()是接受请求并返回响应的可调用视图['get', 'post', 'put', 'patch', 'delete, 'options'.]
```

### 4.5 HttpResponse 对象

1. 在 django.http 模块中定义了 HttpResponse 对象的 API。
2. HttpRequest 对象由 Django 自动创建，HttpResponse 对象由程序员创建。
3. 在每一个视图函数中必须返回一个 HttpResponse 对象,当然也可以是 HttpResponse 子对象。

**1.不用模板,直接返回数据**

```python
from django.http import HttpResponse

def index(request):
    return HttpResponse('你好')
```

**2.调用模板返回数据**

```python
from django.http import HttpResponse

# 返回模板
def index(request):
	return render(request,'user/edit.html',{'info':'你好'})
```

**3.redirect 跳转**

重定向，服务器端跳转。构造函数的第一个参数用来指定重定向的地址，可以简写为 redirect。

```python
from django.shortcuts import redirect
from django.urls import reverse

def index(request):
    return redirect(reverse('myindex')
```

`urls.py 子路由文件`

```py
from django.contrib import admin
from django.urls import path
from polls import views

urlpatterns = [
    path('', views.index, name='index'),
    path('index/', views.index, name='index'),
    path('time/', views.time, name='time'),
    path('redir/', views.redir, name='redir'),
    path('index2/', views.index2, name='index2'),
    path('set_cookie/', views.set_cookie, name='set_cookie'),
    path('get_cookie/', views.get_cookie, name='get_cookie'),
    path('count/', views.count, name='count'),
]
```

### 4.6 JsonResponse 对象

返回 json 数据，一般用于异步请求，帮助用户创建 JSON 编码的响应。

JsonResponse 的默认 Content-Type 为 application/json。

```python
from django.http import JsonResponse

def index2(requeset):
  	data = [
        {'id': 1001, 'name': 'zhangsan', 'age': 20},
        {'id': 1002, 'name': 'lisi', 'age': 22},
        {'id': 1003, 'name': 'wangwu', 'age': 23},
    ]
    return JsonResponse({"data": data})
```

### 4.7 cookie 设置与获取

Cookie 是由 Web 服务器保存在用户浏览器（客户端）上的小文本文件，它可以包含有关用户的信息。

服务器可以利用 Cookies 包含信息的任意性来筛选并经常性维护这些信息，以判断在 HTTP 传输中的状态。

Cookies 最典型的应用是判定注册用户是否已经登录过网站。

**设置 cookie**

```python
# 在Django中，向cookie写入中文字符后会报错
import json

def resp06(request):
    # 获取当前的响应对象
    response = HttpResponse('cookie的设置')

    # 使用响应对象进行cookie的设置
    username = json.dumps('萧兮') # \\u8427\\u516e
    response.set_cookie('user', username)
    print(json.loads(username)) # 打印设置的json字符串的信息

    # 返回响应对象
    return response
```

**获取 cookie**

```python
def get_cookie(request):
    # 读取cookie信息
    cookie = request.COOKIES.get('user', None)
    if cookie:
        return HttpResponse('cookie的读取：' + json.loads(cookie))
    else:
        return HttpResponse('cookie不存在')
```

**使用 cookie 做一个页面访问计数器**

```python
def count(request):
    # 读取
    m = request.COOKIES.get('num', None)
    if m:
        m = int(m) + 1
    else:
        m = 1
    # 获取当前的 响应对象
    response = HttpResponse('cookie记录的计数器值：' + str(m))
    # 使用响应对象进行cookie的设置
    response.set_cookie('num', m)
    # 返回响应对象
    return response
```

### 4.8 HttpReqeust 对象

- 服务器接收到 http 协议的请求后，会根据报文创建 HttpRequest 对象。
- 视图函数的第一个参数是 HttpRequest 对象。
- 在 django.http 模块中定义了 HttpRequest 对象的 API。

**1.属性字段**

下面除非特别说明，属性都是只读的

- path：一个字符串，表示请求的页面的完整路径，不包含域名。
- method：一个字符串，表示请求使用的 HTTP 方法，常用值包括：GET、POST。
- encoding：一个字符串，表示提交的数据的编码方式，默认是`utf-8`的编码方式。这个属性是可写的，可以通过修改它来修改访问表单数据使用的编码，接下来对属性的任何访问将使用新的`encoding值`。
- GET：一个类似于字典的对象，包含 get 请求方式的所有参数。
- POST：一个类似于字典的对象，包含 post 请求方式的所有参数。
- FILES：一个类似于字典的对象，包含所有的上传文件。
- COOKIES：一个标准的 Python 字典，包含所有的 cookie，键和值都为字符串。
- session：一个既可读又可写的类似于字典的对象，表示当前的会话，只有当 Django 启用会话的支持时才可用，详细内容见“状态保持”。

```python
# 测试request对象
def test_request(request):
    print("请求路径", request.path)
    print("请求方法", request.method)
    print("请求编码", request.encoding)
    # print(request.GET)
    print(request.GET['id'])
    print(request.GET.get('name'))
    print(request.GET.get('age', 0))
    return HttpResponse("测试request请求对象")
```

**2.QueryDict 对象**

- request 对象的属性 GET、POST 都是 QueryDict 类型的对象，与 python 字典不同，QueryDict 类型的对象用来处理同一个键带有多个值的情况。

- 方法 `get()` ：根据键获取值

  - 只能获取键的一个值。

  - 如果一个键同时拥有多个值，获取最后一个值

    ```python
    request.GET['age']
    或者
    request.GET.get('age', 0)
    ```

- 方法 `getlist()` ：根据键获取值

  - 将键的值以列表返回，可以获取一个键的多个值

    ```python
    dict.getlist('键',default)
    ```

**3.GET && POST**

一键一值

```python
http://127.0.0.1/get?a=1&b=2&c=3

request.GET['a']
request.GET.get('a',None)
```

一键多值

```python
http://127.0.0.1/get?a=1&a=2&b=3

request.GET.getlist('a',None)
request.POST.getlist('a',None)
```

### 4.9 验证码实战

- 在用户注册、登录页面，为了防止暴力请求，可以加入验证码功能，如果验证码错误，则不需要继续处理，可以减轻一些服务器的压力。
- 使用验证码也是一种有效的防止`crsf`的方法。
- 需要安装扩展：`pip install pillow`
- 验证码效果如下图：

```python
# 验证码的输出
def verifycode(request):
    # 引入绘图模块
    from PIL import Image, ImageDraw, ImageFont
    # 引入随机函数模块
    import random
    # 定义变量，用于画面的背景色、宽、高
    bgcolor = (random.randrange(20, 100), random.randrange(20, 100), 255)
    width = 100
    height = 25
    # 创建画面对象
    im = Image.new('RGB', (width, height), bgcolor)
    # 创建画笔对象
    draw = ImageDraw.Draw(im)
    # 调用画笔的point()函数绘制噪点
    for i in range(0, 100):
        xy = (random.randrange(0, width), random.randrange(0, height))
        fill = (random.randrange(0, 255), 255, random.randrange(0, 255))
        draw.point(xy, fill=fill)
    # 定义验证码的备选值
    str1 = 'ABCD123EFGHIJK456LMNOPQRS789TUVWXYZ0'
    # 随机选取4个值作为验证码
    rand_str = ''
    for i in range(0, 4):
        rand_str += str1[random.randrange(0, len(str1))]
    # 构造字体对象
    font = ImageFont.truetype('static/ariali.ttf', 23)
    # font = ImageFont.load_default().font
    # 构造字体颜色
    fontcolor = (255, random.randrange(0, 255), random.randrange(0, 255))
    # 绘制4个字
    draw.text((5, 2), rand_str[0], font=font, fill=fontcolor)
    draw.text((25, 2), rand_str[1], font=font, fill=fontcolor)
    draw.text((50, 2), rand_str[2], font=font, fill=fontcolor)
    draw.text((75, 2), rand_str[3], font=font, fill=fontcolor)
    # 释放画笔
    del draw
    # 存入session，用于做进一步验证
    # request.session['verifycode'] = rand_str

    # 内存文件操作
    import io
    buf = io.BytesIO()
    # 将图片保存在内存中，文件类型为png
    im.save(buf, 'png')
    # 将内存中的图片数据返回给客户端，MIME类型为图片png
    return HttpResponse(buf.getvalue(), 'image/png')
```

上述代码解释 :

- 定义函数 verifycode。
- `Image` 表示画布对象
- `ImageDraw` 表示画笔对象
- `ImageFont` 表示字体对象

`urls.py`里面的使用方式

```py
from django.contrib import admin
from django.urls import path, include
from one import views

urlpatterns = [
    path('index/', views.index, name='index'),
    path('verifycode/', views.verifycode, name='verifycode'),
]
```

`views.py`的使用方式

```py
from django.shortcuts import render
from django.http import HttpResponse


# 首页
def index(request):
    return render(request, 'one/index.html')
# 验证码
def verifycode(request):
    ...
```

在模板的 html 文件中,可以直接引用

```python
<img src="{% url 'verifycode' %}" alt="">
```

## 5. Django 的模板层

### 5.1Template 模板

作为 Web 框架，Django 需要一种很便利的方法以动态地生成 HTML。最常见的做法是使用模板。

模板包含所需 HTML 输出的静态部分，以及一些特殊的语法，描述如何将动态内容插入。

**模板引擎配置**

模板引擎使用该 TEMPLATES 设置进行配置，在做下面模板配置的同时，也要在项目的根目录下创建一个`templates`目录。

```python
# 项目目录下的settings.py配置文件添加TEMPLATES中的DIRS配置
TEMPLATES = [
        {
            'BACKEND': 'django.template.backends.django.DjangoTemplates',
            'DIRS': [os.path.join(BASE_DIR,'templates')],
            'APP_DIRS': True,
            'OPTIONS': {
                'context_processors': [
                    'django.template.context_processors.debug',
                    'django.template.context_processors.request',
                    'django.contrib.auth.context_processors.auth',
                    'django.contrib.messages.context_processors.messages',
                ],
            },
        },
    ]
```

![image-20220909145156375](http://mk.xxoutman.cn/django/image-20220909145156375.png)

### 5.2 模板语法

**1.变量**

- 变量输出语法

  ```js
  {{  var  }}

  当模版引擎遇到一个变量，将计算这个变量，然后将结果输出。
  变量名必须由字母、数字、下划线（不能以下划线开头）和 点 组成。
  如果变量不存在， 模版系统将插入空字符串。
  在模板中调用方法时不能传递参数。
  ```

**2.标签**

- 标签语法

  ```python
  {%  tag  %}

  在输出中创建文本。
  控制循环或逻辑。
  加载外部信息到模板中。
  ```

**3.for 标签**

```js
{%  for ... in ...  %}
    循环逻辑
{%  endfor  %}
```

**4.if 标签**

```js
{%  if ...  %}
    逻辑1
{%  elif ...  %}
    逻辑2
{%  else  %}
    逻辑3
{%  endif  %}
```

**5.comment 标签**

```js
{%  comment  %}
    多行注释
{%  endcomment  %}
```

**6.include：加载模板并以标签内的参数渲染**

```js
{%  include "base/index.html"  %}
```

**7.url：反向解析**

```js
{%  url 'name' p1 p2  %}
```

**8.csrf_token：这个标签用于跨站请求伪造保护**

```js
{%  csrf_token  %}
```

**9.过滤器**

- 语法：

  ```js
  {{  变量|过滤器  }}

  例如{{  name|lower  }}，表示将变量name的值变为小写输出
  ```

- 使用管道符号 (|)来应用过滤器。

- 通过使用过滤器来改变变量的计算结果。

- 关闭 HTML 自动转义。

- ```py
    {{  data|safe  }}
  ```

- 可以在 `if` 标签中使用过滤器结合运算符。

- ```py
    if list1|length > 1
  ```

- 过滤器能够被“串联”，构成过滤器链。

- ```py
    name|lower|upper
  ```

- 过滤器可以传递参数，参数使用引号包起来。

- ```py
    list|join:", "
  ```

- default：如果一个变量没有被提供，或者值为 false 或空，则使用默认值，否则使用变量的值。

- ```py
    value|default:"什么也没有"
  ```

- date：根据给定格式对一个 date 变量格式化。

- ```py
    value|date:'Y-m-d H:i:s' #年月日 时分秒
  ```

- 官方文档内置过滤器参考：

- 网址：https://docs.djangoproject.com/zh-hans/2.2/ref/templates/builtins/#ref-templates-builtins-filters

**9.自定义过滤器**

1.在你的`应用程序`下创建 templatetags 文件夹(必须是这个名字)

如果文件夹名字不是 templatetags 可能会出现以下错误
![在这里插入图片描述](http://mk.xxoutman.cn/django/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAUHl0aG9uNDU0,size_20,color_FFFFFF,t_70,g_se,x_16.png)

在 templatetags 文件夹下创建`my_tags.py`(文件名可自定义)

![在这里插入图片描述](http://mk.xxoutman.cn/django/8191090afa5145bb8b054bf00637aed8.png)

2.导入注册过滤器的 Library 实例

编写`my_tags.py`代码如下

```py
from django import template
# 下面代码会直接使用register
register = template.Library()

#自定义过滤器(不传值)
@register.filter
def my_tag(value):
    """
    value: 是必须的参数  是模板过滤器中|前面的值
    """
    return value + '过滤器'

'''
{# my_tags是过滤器的文件名 #}
{# 意思是导入my_tags模板过滤器 #}

{% load my_tags %}

<h2>{{ '你好'|my_tag }}</h2>
'''

#自定义过滤器(传值)
@register.filter
def my_tag(value, value2):
    """
    value: 是必须的参数  是模板过滤器中|前面的值
    value2: 是模板过滤器中 : 后面的值
    """
    return value + value2

'''
{# my_tags是过滤器的文件名 #}
{# 意思是导入my_tags模板过滤器 #}

{% load my_tags %}

<h2>{{ '你好'|my_tag:'我是过滤器' }}</h2>

'''
```

**10.注释**

- 单行注释

```
{# 注释 #}
```

- 多行注释

```
{%  comment  %}
      多行注释
{%  endcomment  %}
```

**11.模板运算**

- 加

  ```js
  { {  value|add:10  } }
  note:value=5,则结果返回 15。
  ```

- 减

  ```js
  { {  value|add:-10  } }
  note:value=5,则结果返回-5，加一个负数就是减法了
  ```

- 乘

  ```js
  { %  widthratio 5 1 100  % }
  note:等同于：(5 / 1) * 100 ，结果返回500，
  withratio需要三个参数，它会使用参数1/参数2*参数3的方式进行运算，进行乘法运算，使「参数2」=1
  ```

- 除

  ```js
  { %  widthratio 5 100 1  % }
  note:等同于：(5 / 100) * 1,则结果返回0.05,和乘法一样，使「参数3」= 1就是除法了。
  ```

**12.案例**

`views.py`

```py
from django.shortcuts import render
from django.http import HttpResponse
from datetime import datetime

# 视图模板
def template(request):
    # 构造数据
    context = {
        'name': '萧兮',
        'fruits': ['香蕉', '苹果', '火龙果'],
        'obj': {'name': '剑豪', 'age': 20},
        'data': [
            {'name': '海绵宝宝', 'sex': 1, 'age': 40, 'state': 0},
            {'name': '派大星', 'sex': 0, 'age': 38, 'state': 2},
            {'name': '痞老板', 'sex': 1, 'age': 20, 'state': 1},
            {'name': '蟹老板', 'sex': 0, 'age': 18, 'state': 2},
        ],
        'time': datetime.now,
        'case': 'Django',
        'num1': 100,
        'num2': 20
    }
    return render(request, 'one/template.html', context)
```

`one/template.html`

```python
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body>
<h1>Django的模板语法实例，</h1>
<a href="{% url 'index' %}">跳转到首页</a>
<h3>1.模板变量输出</h3>
<ul>
    <li>普通变量: {{ name }}</li>
    <li>对象中的key: {{ obj.name }}</li>
    <li>数组中的元素渲染: {{ fruits.1 }}</li>
</ul>
<h3>2.模板中标签的使用</h3>
<table width="500" border="1">
    <tr>
        <th>姓名</th>
        <th>性别</th>
        <th>年龄</th>
        <th>状态</th>
    </tr>
    {% for item in  data %}
        <tr>
            <td>{{ item.name }}</td>
            <td>{% if item.sex == 1 %}男{% else %}女{% endif %}</td>
            <td>{{ item.age }}</td>
            <td>
                {% if item.state == 0 %}
                    管理员
                {% elif item.state == 1 %}
                    VIP账户
                {% else %}
                    <span style="color: red">禁用账户</span>
                {% endif %}

            </td>
        </tr>
    {% endfor %}
</table>

<h3>3.令牌是一个隐藏域</h3>
<div>{% csrf_token %}</div>

<h3>4.过滤器的使用</h3>
<ul>
    <li>原值: {{ case }}</li>
    <li>大写过滤器: {{ case|upper }}</li>
    <li>小写过滤器: {{ case|lower }}</li>
    <li>时间过滤器: {{ time|date:'Y-m-d H-i-s' }}</li>
</ul>
<h3>5.模板中的运算</h3>
<li>两个数: {{ num1 }},{{ num1 }}</li>
<li>求和: {{ num1|add:num2 }}</li>
<li>减法: {{ num1|add:-20 }}</li>
<li>乘法: {% widthratio num1 1 num2 %}</li>
<li>除法: {% widthratio num1 num2 1 %}</li>

<h3>6.include语句的使用</h3>
{% include "one/contains.html" %}

</body>
</html>
```

`one/contains.html`

```html
<h1>哈哈哈,我是contains的其他模块</h1>
```

### 5.3 模板继承

- 模板继承可以减少页面内容的重复定义，实现页面内容的重用，典型应用：网站的头部、尾部是一样的，这些内容可以定义在父模板中，子模板不需要重复定义。
- block 标签 ：在父模板中预留区域，在子模板中填充。
- extends ：继承，写在子模板文件的第一行。

定义父模板 base.html

```js
{ %  block block_name  % }
   这里可以定义默认值
   如果不定义默认值，则表示空字符串
{ %  endblock  % }
```

- 定义子模板 index.html

```
{ %  extends "base.html"  % }
```

- 在子模板中使用 block 填充预留区域

```js
{ %  block block_name  % }
实际填充内容
{ %  endblock  % }
```

**案例**

`base.html`

```py
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>{% block title %}{% endblock %}</title>
    {% block head %}{% endblock %}
</head>
<body>
{% block body %} 我是页面主体内容 {% endblock %}
</body>
</html>
```

`子模板.html`

```py
{% extends "one/base.html" %}

{% block title %}
    子模板的标题
{% endblock %}

{% block head %}
    <style>
        body {
            background: pink
        }
    </style>
{% endblock %}

{% block body %}
	{# 继承父模板里面的默认内容 #}
    {{ block.super }}
    <div>我是子模板里面的内容</div>
{% endblock %}
```

**说明**

- 如果在模版中使用 extends 标签，它必须是模版中的第一个标签。
- 不能在一个模版中定义 多个相同名字 的 block 标签。
- 子模版不必定义全部父模版中的 blocks，如果子模版没有定义 block，则使用了父模版中的默认值。

- 子模板想继承父模板里面的默认内容,可以使用 `{{ block.super }}`。

**案例: 三层继承结构**

- 三层继承结构使代码得到最大程度的复用，并且使得添加内容更加简单
- 如下图为常见的电商页面

#### 1.创建根级模板

- 名称为“base.html”
- 存放整个站点共用的内容

```py
<!DOCTYPE html>
<html>
    <head>
        <title>{%  block title  %}{%  endblock  %} 水果超市</title>
    </head>
    <body>
        top--{{logo}}
        <hr/>
        { %  block left  % }

        { %  endblock  % }

        { %  block content  % }

        { %  endblock  % }
        <hr/>
        bottom
    </body>
</html>
```

#### 2.创建分支模版

- 继承自 base.html
- 名为“base\_\*\*\*.html”
- 定义特定分支共用的内容
- 定义 base_goods.html

```js
{ %  extends 'temtest/base.html'  % }

{ %  block title  % }商品{ %   endblock   % }

{ %  block left  % }
    <h1>goods left</h1>
{ %  endblock  % }
```

- 定义 base_user.html

```js
{ %  extends 'temtest/base.html'  % }

{ %  block title  % }用户中心{ %  endblock   % }

{ %  block left  % }
    <font color='blue'>user left</font>
{ %  endblock  % }
```

- 定义 index.html，继承自 base.html，不需要写 left 块

```js
{ %  extends 'temtest/base.html'  % }

{ %  block content  % }
    首页内容
{ %  endblock content  % }
```

#### 3.为具体页面创建模板，继承自分支模板

- 定义商品列表页 goodslist.html

```js
{ %  extends 'temtest/base_goods.html'  % }
{ %  block content  % }
    商品正文列表
{ %  endblock content  % }
```

- 定义用户密码页 userpwd.html

```js
{ %  extends 'temtest/base_user.html'  % }
{ %  block content  % }
    用户密码修改
{ %  endblock content  % }
```

#### 4.视图调用具体页面，并传递模板中需要的数据

- 首页视图 index

```py
logo='welcome to itcast'
def index(request):
    return render(request, 'temtest/index.html', {'logo': logo})
```

- 商品列表视图 goodslist

```py
def goodslist(request):
    return render(request, 'temtest/goodslist.html', {'logo': logo})
```

- 用户密码视图 userpwd

```py
def userpwd(request):
    return render(request, 'temtest/userpwd.html', {'logo': logo})
```

#### 5.配置 url

```py
from django.urls import path
from . import views
urlpatterns = [
    path('', views.index, name='index'),
    path('list/', views.goodslist, name='list'),
    path('pwd/', views.userpwd, name='pwd'),
]
```

## 6. Django 常用 web 工具

### 6.1 文件上传

- 当 Django 在处理文件上传的时候，文件数据被保存在`request.FILES`。
- FILES 中的每个键为\<input type="file" name="" />中的 name 属性值。
- 注意：FILES 只有在请求的方法为 POST 且提交的\<form>带有 enctype="multipart/form-data" 的情况下才会包含数据。否则，FILES 将为一个空的类似于字典的对象。

`settings.py`

```py
STATIC_URL = '/static/'
# 静态资源目录
STATICFILES_DIRS = (os.path.join(BASE_DIR, 'static'),)
```

![image-20220912193859070](http://mk.xxoutman.cn/django/image-20220912193859070.png)

`应用程序/urls.py`

```py
from django.contrib import admin
from django.urls import path, include
from file import views

urlpatterns = [
    # 文件上传路由配置
    path('upload_file/', views.upload_file, name="upload_file"),
    path('do_upload/', views.do_upload, name="do_upload")
]
```

`应用程序/views.py`

```py
from django.shortcuts import render
from django.http import HttpResponse
import time
from PIL import Image


# 文件上传
def upload_file(request):
    return render(request, 'file/upload.html')


# 执行文件上传处理
def do_upload(request):
    myfile = request.FILES.get("pic", None)  # 获取文件名称
    print(myfile.name)
    if not myfile:
        return HttpResponse("没有上传的文件信息")

    # 生成上传后的文件名
    filename = str(time.time()) + "." + myfile.name.split('.').pop()

    # 在这里然后读取文件信息 二进制
    destination = open(f'./static/pics/{filename}', 'wb+')
    for chunk in myfile.chunks():  # 分块读取上传文件内容并写入目标文件
        destination.write(chunk)
    destination.close()

    # 执行图片缩放
    im = Image.open("./static/pics/" + filename)
    # 缩放到75*75(缩放后的宽高比例不变):
    im.thumbnail((75, 75))
    # 把缩放后的图像用jpeg格式保存:
    im.save("./static/pics/s_" + filename, None)

    return HttpResponse("上传文件成功："+filename)

```

### 6.2 分页操作

Django 提供了一些类实现管理数据分页，这些类位于 django/core/paginator.py 中。

**Paginator 对象**

- Paginator(列表,int)：返回分页对象，参数为列表数据，每页数据的条数。

**属性**

- count：对象总数
- num_pages：页面总数
- page_range：页码列表，从 1 开始，例如[1, 2, 3, 4]

**方法**

- page(num)：下标以 1 开始，如果提供的页码不存在，抛出 InvalidPage 异常

**异常 exception**

- InvalidPage：当向 page()传入一个无效的页码时抛出
- PageNotAnInteger：当向 page()传入一个不是整数的值时抛出
- EmptyPage：当向 page()提供一个有效值，但是那个页面上没有任何对象时抛出

  **案例**

在以前的学生信息管理系统中

`应用程序/urls.py`

```py
from unicodedata import name
from django.urls import path
from . import views

# 配置子路由
urlpatterns = [
    path("", views.index, name="index"),
    path("indexUsers", views.indexUsers, name="indexUsers"),
    path("pageUsers/<int:pIndex>", views.pageUsers, name="pageUsers"),  # 分页浏览用户信息
    path("addUsers", views.addUsers, name="addUsers"),
    path("insertUsers", views.insertUsers, name="insertUsers"),
    path("delUsers/<int:uid>", views.delUsers, name="delUsers"),
    path("editUsers/<int:uid>", views.editUsers, name="editUsers"),
    path("updateUsers", views.updateUsers, name="updateUsers"),
]
```

`应用程序/views.py`

```py
# 分页浏览用户信息
def pageUsers(request, pIndex=1):
    try:
        # 获取搜索的关键字
        kw = request.GET.get('keyword')
        print(kw)
        query = ''  # 定义一个用于存储搜索条件的变量
        if kw is not None:
            list = User.objects.filter(name__contains=kw)  # 对name字段做包含式查询(模糊查询)
            query = f'?keyword={kw}'
        else:
            list = User.objects.filter()  # 获取分页用户信息

        p = Paginator(list, 5)  # 以5条数据一页实例化对象
        # 判断页码值是否有效
        if pIndex < 1:
            pIndex = 1
        if pIndex > p.num_pages:
            pIndex = p.num_pages
        ulist = p.page(pIndex)  # 拿到第一页的数据
        context = {"ulist": ulist, 'pIndex': pIndex, 'pagelist': p.page_range, 'query': query}
        return render(request, "User/index2.html", context)  # 加载模板
    except:
        return HttpResponse("没有找到用户信息!")
```

`emplates/index2.html`

```py
{#搜索框#}
<form action="{% url 'pageUsers' 1 %}" method="get">
    姓名：<input type="text" size="10" name="keyword" value="{{ query|my_tag }}"/>
    <input type="submit" value="搜索"/>
</form>

{# 分页操作 #}
<br>
<a href="{% url 'pageUsers' pIndex|add:-1 %}{{ query }}">上一页</a>
{% for p in pagelist %}
    {% if pIndex == p %}
        &nbsp;&nbsp; <a href="{% url 'pageUsers' p %}{{ query }}" style="color:red;">{{ p }}</a>&nbsp;&nbsp;
    {% else %}
        &nbsp;&nbsp; <a href="{% url 'pageUsers' p %}{{ query }}">{{ p }}</a>&nbsp;&nbsp;
    {% endif %}
{% endfor %}
<a href="{% url 'pageUsers' pIndex|add:1 %}{{ query }}">下一页</a>
```

`应用程序/templatetags/my_tags.py`

注意: 这个文件夹 templatetags 必须放在我们创建的应用程序中。

```py
# 自定义过滤器

from django import template

# 下面代码会直接使用register
register = template.Library()

@register.filter
def my_tag(value):
    """
    value: 是必须的参数  是模板过滤器中|前面的值
    """
    try:
        result = value.split(r'=')[1]
    except:
        result = ''
    return result

'''
{# my_tags是过滤器的文件名 #}
{# 意思是导入my_tags模板过滤器 #}

{% load my_tags %}

<h2>{{ '你好'|my_tag }}</h2>
'''
```

### 6.3 富文本编译器

Django 集成 UEditor (封装成应用) 百度富文本编辑器

![img](http://mk.xxoutman.cn/django/33-16629838652591.png)

**配置方法**

![image-20220912195855001](http://mk.xxoutman.cn/django/image-20220912195855001.png)

`settings.py`

```py
'DIRS': [os.path.join(BASE_DIR, 'templates')],

STATIC_URL = '/static/'
STATICFILES_DIRS = (
    os.path.join(BASE_DIR, "static"),
)
```

`应用程序/views.py`

```py
from django.shortcuts import render
from django.http import HttpResponse


# Create your views here.
def index(request):
    return HttpResponse('首页内容')


# markdown语法插件
def markdown(request):
    return render(request, 'edit_app/editor.html')
```

`应用程序/urls.py`

```py
from django.contrib import admin
from django.urls import path, include
from edit_app import views

urlpatterns = [
    path('', views.index, name='index'),
    path('markdown/', views.markdown, name='markdown'),
]
```

`templates/edit_app/editor.html`

```py
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <link rel="stylesheet" type="text/css" href="/static/ueditor/UE/third-party/SyntaxHighlighter/shCoreDefault.css">
    <script type="text/javascript" src="/static/ueditor/UE/third-party/SyntaxHighlighter/shCore.js"></script>
    <script type="text/javascript" src="/static/ueditor/UE/ueditor.config.js"></script>
    <script type="text/javascript" src="/static/ueditor/UE/ueditor.all.min.js"></script>
    <script type="text/javascript" src="/static/ueditor/UE/lang/zh-cn/zh-cn.js"></script>
</head>
<body>
<h2>富文本编辑器的使用</h2>

<div class="am-form-group">
    <label for="user-intro" class="am-u-sm-3 am-form-label">商品简介</label>
    <div class="am-u-sm-9">
        <!-- <textarea name="descr" class="" rows="10" id="user-intro" placeholder="请输入商品简介"></textarea> -->
        <!-- <script id="editor" type="text/plain" style="width:100%;height:500px;"></script> -->
        <script id="editor" name="content" type="text/plain" style="height:500px;"></script>
    </div>
</div>

<script type="text/javascript">
    var ue = UE.getEditor('editor');
    SyntaxHighlighter.all();

    {# 监听富文本编译器失去焦点事件 #}
    ue.addListener("blur", function () {
        let html = ue.getContent();
        console.log(html)
    })
</script>

</body>
</html>
```

### 6.4 发送邮件

`settings.py`

```py
# 邮箱配置
EMAIL_USE_SSL = True
EMAIL_HOST = 'smtp.qq.com'  # 如果是 163 改成 smtp.163.com
EMAIL_PORT = 465
EMAIL_HOST_USER = '1693889638@qq.com'  # 配置邮箱
EMAIL_HOST_PASSWORD = 'ghotnkzapgyfdjga'  # 对应的授权码
DEFAULT_FROM_EMAIL = EMAIL_HOST_USER  # 默认邮箱发送者
EMAIL_FROM = '萧兮网络验证<1693889638@qq.com>'  # 收件人看到的发件人
```

`views.py`

```py
# 引入相关模块
from django.conf import settings
from django.core.mail import send_mail
from django.http import HttpResponse


def check_mail(request):
    msg = '''<div style="color:red;">测试django发送邮件!</div>'''
    send_mail(
        subject='注册验证码邮件',
        message=msg,
        from_email=settings.EMAIL_HOST_USER,
        recipient_list=["671781813@qq.com"],  # 把这条邮件信息发送给xxxx@qq.com的邮箱
    )
    return HttpResponse('测试邮件已发出请注意查收')
```

`urls.py`

```py
from django.contrib import admin
from django.urls import path, include
from emails import views

urlpatterns = [
    path("check_mail/", views.check_mail, name='check_mail'),
]
```

## 7.Django 其他核心功能

### 7.1 静态文件

加载静态资源 `{% load static from staticfiles %}`

然后在加载静态资源 `<img src="{% static '/mypics/Penguins.jpg' %}" width="300"/>`

```html
{% load static from staticfiles %}
<head>
	<meta charset="UTF-8">
	<title>Django框架使用案例</title>
</head>
<body>
	<h2>欢饮使用Django框架</h2>

	<ul>
		<li><a href="{% url 'index' %}">返回首页</a></li>
	</ul>

	<img src="/static/mypics/Penguins.jpg" width="300"/>
	<img src="{% static '/mypics/Penguins.jpg' %}" width="300"/>
</body>
</html>
```
